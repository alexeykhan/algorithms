package main

// FirstLastIndices находит индекс первого и последнего вхождения искомого
// значения в заданном отсортированном массиве, в котором возможны повторы.
// В случае, если нет вхождений, вернуть [-1, -1]
func FirstLastIndices(x interface{}, a []int) (int, int) {
	first, last := -1, -1
	for i, y := range a {
		if y == x {
			if first == -1 {
				first = i
			}
			last = i
		}
	}
	return first, last
}

// FindDuplicateNumber решает следующую задачу:
// Имея массив из N + 1 чисел, где каждое число — от 1 до N (включительно),
// докажите, что должно существовать как минимум одно число с дублем в массиве.
// Важные условия:
// - В массиве только 1 число с дублями, но самих дублей может быть несколько
// - Нельзя изменять исходный массив (нельзя сортировать, менять значения и тд.)
// - Для решения задачи можно использовать константную O(1) память
// - Сложность алгоритма должна быть меньше O(n^2)
func FindDuplicateNumber(a []int) int {

	// [-] Можно отсортировать массив и найти первые два рядом стоящих числа, но
	// это нарушает запрет изменять исходный массив.

	// [-] Можно добавлять в хеш все встреченные по пути обхода массива значения и
	// как найти первый найденный в хеше, но тогда мы нарушим ограничение на
	// константную память O(1) - чем больше массив, тем больше места может
	// понадобиться для хранения просмотренных значений.

	// [+] Рабочее решение: если считать массив списком инструкций по сдвигу
	// каретки с текущего индекса на значение текущего индекса, в нем всегда
	// будут циклы, так как у нас конечный массив, а значит, передвигая каретку
	// от ячейки к ячейки, в какой-то момент мы зациклимся. Если пустить по
	// массиву две параллельных каретки, одна из которых будет двигаться в 2 раза
	// быстрее другой, в какой-то момент они столкнуться в одной ячейке. При этом
	// за 1 шаг до столкновения они будут находиться в разных ячейках, у которых
	// будет одинаковое значение (индекс ячейки, в которой они столкнуться), а
	// значит мы нашли искомое число с дублями в массиве.

	hare := a[0]
	tortoise := a[0]
	for {
		hare = a[a[hare]]
		tortoise = a[tortoise]
		if hare == tortoise {
			break
		}
	}

	ptr1 := a[0]
	ptr2 := tortoise
	for ptr1 != ptr2 {
		ptr1 = a[ptr1]
		ptr2 = a[ptr2]
	}

	return ptr1
}
